# Deribit Price Tracker

Система для отслеживания цен криптовалют с биржи Deribit и предоставления API для доступа к историческим данным.

## Описание

Приложение состоит из двух основных компонентов:
1. **Celery Worker** - периодически получает индексные цены BTC_USD и ETH_USD с биржи Deribit и сохраняет их в PostgreSQL
2. **FastAPI Application** - предоставляет REST API для получения сохраненных данных о ценах

## Технологический стек

- **FastAPI** - веб-фреймворк для API
- **PostgreSQL** - реляционная база данных
- **Celery** - распределенная система задач
- **Redis** - брокер сообщений для Celery
- **SQLAlchemy** - ORM для работы с БД
- **aiohttp** - асинхронный HTTP клиент
- **Docker** - контейнеризация приложения

## Требования

- Docker и Docker Compose
- Python 3.11+ (для локальной разработки)

## Развертывание

### Использование Docker Compose (рекомендуется)

1. Клонируйте репозиторий:
```bash
git clone <repository-url>
cd deribit-price-tracker
```

2. Создайте файл `.env` в корне проекта (можно скопировать из `.env.example`):
```env
POSTGRES_USER=deribit_user
POSTGRES_PASSWORD=deribit_password
POSTGRES_DB=deribit_db
POSTGRES_HOST=db
POSTGRES_PORT=5432
REDIS_HOST=redis
REDIS_PORT=6379
CELERY_BROKER_URL=redis://redis:6379/0
CELERY_RESULT_BACKEND=redis://redis:6379/0
```

3. Запустите приложение:
```bash
docker-compose up -d
```

4. Приложение будет доступно по адресу: `http://localhost:8000`
5. Документация API: `http://localhost:8000/docs`

### Локальное развертывание

1. Установите зависимости:
```bash
pip install -r requirements.txt
```

2. Настройте PostgreSQL и Redis (должны быть запущены локально)

3. Создайте файл `.env` с настройками подключения к БД и Redis

4. Примените миграции:
```bash
alembic upgrade head
```

5. Запустите Celery worker:
```bash
celery -A app.celery_app worker --loglevel=info
```

6. Запустите Celery beat (для периодических задач):
```bash
celery -A app.celery_app beat --loglevel=info
```

7. Запустите FastAPI приложение:
```bash
uvicorn app.main:app --reload
```

## Использование API

### 1. Получение всех сохраненных данных по валюте

```bash
GET /api/prices?ticker=BTC_USD
```

### 2. Получение последней цены валюты

```bash
GET /api/prices/last?ticker=ETH_USD
```

### 3. Получение цены с фильтром по дате

```bash
GET /api/prices/filter?ticker=BTC_USD&start_date=2024-01-01&end_date=2024-01-31
```

Все методы требуют обязательный query-параметр `ticker` (BTC_USD или ETH_USD).

## Структура проекта

```
deribit-price-tracker/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI приложение
│   ├── config.py               # Конфигурация
│   ├── database.py             # Подключение к БД
│   ├── models.py               # SQLAlchemy модели
│   ├── schemas.py              # Pydantic схемы
│   ├── services/
│   │   ├── __init__.py
│   │   ├── deribit_client.py   # Клиент Deribit
│   │   └── price_service.py    # Сервис для работы с ценами
│   ├── api/
│   │   ├── __init__.py
│   │   └── routes.py           # API роуты
│   ├── celery_app.py           # Конфигурация Celery
│   └── tasks.py                # Celery задачи
├── alembic/                    # Миграции БД
├── tests/                      # Unit тесты
├── docker-compose.yml
├── Dockerfile
├── requirements.txt
└── README.md
```

## Тестирование

Запуск тестов:
```bash
pytest tests/ -v
```

## Design Decisions

### Архитектура

1. **Разделение ответственности**: Приложение разделено на слои (API, Services, Models), что обеспечивает чистую архитектуру и упрощает тестирование.

2. **Использование Dependency Injection**: Конфигурация и зависимости передаются через конструкторы классов, что исключает использование глобальных переменных и упрощает тестирование.

3. **Асинхронность**: Использование `aiohttp` для клиента Deribit и `async/await` в FastAPI обеспечивает высокую производительность при работе с I/O операциями.

### База данных

1. **PostgreSQL**: Выбрана как надежная и производительная реляционная БД с поддержкой индексов для быстрого поиска по датам и тикерам.

2. **SQLAlchemy ORM**: Использование ORM упрощает работу с БД и обеспечивает миграции через Alembic.

3. **Индексы**: Созданы индексы на поля `ticker` и `timestamp` для оптимизации запросов по фильтрации.

### Периодические задачи

1. **Celery**: Выбран для выполнения периодических задач, так как это стандартное решение для Python приложений с поддержкой распределенных задач.

2. **Redis как брокер**: Redis используется как брокер сообщений для Celery из-за простоты настройки и высокой производительности.

3. **Периодичность**: Задача настроена на выполнение каждую минуту через `beat_schedule` в Celery.

### API Design

1. **RESTful подход**: Использованы стандартные HTTP методы (GET) и понятные URL структуры.

2. **Обязательный параметр ticker**: Все методы требуют параметр `ticker` для обеспечения безопасности и валидации входных данных.

3. **Pydantic схемы**: Использованы для валидации входных и выходных данных API.

### Контейнеризация

1. **Docker Compose**: Использован для оркестрации контейнеров (приложение, БД, Redis), что упрощает развертывание и разработку.

2. **Отдельные контейнеры**: Приложение и база данных развернуты в отдельных контейнерах для соблюдения принципа разделения ответственности.

### Обработка ошибок

1. **Исключения**: Реализованы кастомные исключения для обработки ошибок клиента Deribit и валидации данных.

2. **HTTP статус коды**: Использованы правильные HTTP статус коды (404 для не найденных данных, 400 для ошибок валидации).

### Тестирование

1. **Unit тесты**: Написаны тесты для основных методов сервисов и API endpoints с использованием моков.

2. **Pytest**: Выбран как стандартный фреймворк для тестирования Python приложений.
